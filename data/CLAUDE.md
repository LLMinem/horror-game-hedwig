# Cemetery GeoJSON (Neuer Friedhof, Bruchköbel) — for Three.js

This directory contains a single production-ready GeoJSON you can feed to your game logic, plus one optional script if you ever want to regenerate buffered surfaces/hedges yourself.

## Files you actually need

- `~/Projects/horror-game/data/cemetery_game_final.geojson`  
  The dataset. Includes boundary, fence, paths-as-polygons, hedges-as-polygons, buildings and POIs (toilets, bicycle parking, water taps, etc.). **Use this file.**

- `~/Projects/horror-game/data/buffer-surfaces.js` _(optional)_  
  A tiny Node script that turns OSM path/hedge lines into polygons (buffers). Only needed if you plan to re-run buffering on a different raw export.

---

## Run the script without adding dependencies to your project

> Skip this section if you’re only consuming `cemetery_game_final.geojson`.

### Option A (recommended): one-off run with `npx` (no package.json changes)

From the data folder:

```bash
cd ~/Projects/horror-game/data

npx -y -p @turf/turf node buffer-surfaces.js \
  ./cemetery_raw.geojson ./cemetery_game_final.geojson \
  --hedge-width 1.2 \
  --paving-width 3.0 \
  --gravel-width 2.4 \
  --service-width 4.0 \
  --no-clip-hedges     # remove this flag if you prefer clipping hedges to paths
```

- Width flags are **total widths in meters**.
- Output is pretty-printed GeoJSON by default. Add `--minify` to shrink the file.
- If you keep `--no-clip-hedges`, hedges may intersect paths; your renderer should draw **paths above hedges**.

### Option B: create a standalone one-file build, then run with plain Node

```bash
cd ~/Projects/horror-game/data

# Build a self-contained file that already includes Turf (no dev deps saved)
npx -y esbuild buffer-surfaces.js --bundle --platform=node --format=cjs \
  --outfile=buffer-surfaces.standalone.cjs

# Use it any time without installing anything:
node buffer-surfaces.standalone.cjs ./cemetery_raw.geojson ./cemetery_game_final.geojson \
  --hedge-width 1.2 --no-clip-hedges
```

---

## Geometry & Layers

What’s in `cemetery_game_final.geojson`:

- **Cemetery boundary** — `Polygon` (outer boundary of the site).

  - Marks playable area and can serve as a hard fence line.
  - Properties include `landuse=cemetery`, `name=Neuer Friedhof`, and `kind: "cemetery_boundary"`.

- **Fence** — `LineString` around the boundary (derived).

  - Use to spawn/visualize a fence mesh or to mark a non-traversable border.
  - Properties include `barrier=fence` and `from: "boundary"`.

- **Surfaces (paths/driveways)** — `Polygon` (generated by buffering OSM `highway` lines).

  - Properties:
    - `type: "surface"`
    - `highway: "path" | "footway" | "service"`
    - `surface` (e.g. `asphalt`, `gravel`, `sett`)
    - `surface_class: "paving" | "gravel"`
    - `generated_from: "line_buffer"`
    - `generated_width_m` (total width used for buffering)

- **Hedges** — `Polygon` (generated by buffering `barrier=hedge`).

  - Properties:
    - `type: "hedge"`
    - `generated_from: "line_buffer"`
    - `generated_width_m` (e.g. `1.2`)
  - Note: some hedge polygons may overlap surface polygons if you used `--no-clip-hedges`. Your renderer should give **paths priority** (draw above) so hedges don’t “grow over” paths.

- **Buildings** — `Polygon`

  - Includes `amenity=funeral_hall`, `building=funeral_hall`, `building=garages`, `building=warehouse`, etc.

- **POIs** — `Point`
  - `amenity=toilets` (with `unisex=yes`)
  - `man_made=water_tap` (multiple taps)
  - `amenity=bicycle_parking`
  - `amenity=recycling` (`recycling_type=container`, `recycling:green_waste=yes`)
  - `man_made=tower` with `tower:type=bell_tower`, `tower:construction=wood`

---

## Properties (columns) observed

These are the keys you’ll encounter across features (not every feature has every key):

```
@id
amenity
building
description
man_made
barrier
cemetery
covered
construction:cemetery
access
locked
noexit
tower:construction
tower:type
recycling:green_waste
recycling_type
unisex
highway
lit
service
surface
type
surface_class
generated_from
generated_width_m
kind          # used by cemetery boundary (e.g. "cemetery_boundary")
from          # used by fence to note it was derived "from":"boundary"
```

---

## Using this file with an AI agent / game pipeline

- **Don’t load the entire file into an LLM context.** Instead:

  - Parse the GeoJSON in code.
  - Filter by `type`, `highway`, `amenity`, etc.
  - Build meshes per layer (boundary, surfaces, hedges, buildings, POIs).
  - Render order tip: draw _surfaces_ above ground; draw _hedges_ after ground but **below** surfaces if you kept `--no-clip-hedges`.

- **Example filter (pseudocode):**

```js
// surfaces
features.filter((f) => f.properties?.type === "surface");

// hedges
features.filter((f) => f.properties?.type === "hedge");

// water taps
features.filter((f) => f.properties?.man_made === "water_tap");
```

- **Coordinate system:** WGS84 lon/lat. Buffer widths were specified in meters when generating polygons, so reproject to a planar space or let your engine handle scaling when placing meshes.

---

## License & attribution

Data is derived from OpenStreetMap and is available under the ODbL. Please attribute OSM contributors in your game/credits.
